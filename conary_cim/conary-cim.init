#!/bin/bash
#
# chkconfig: 2345 15 92
#
# description: rPath Remote Update enabler
#
# processname:
#

LOCK_FILE="/var/lock/subsys/conary-cim"
LOG_FILE="/var/log/conary-cim.log"

log_info()
{
    echo $(date -u +"%Y-%m-%d %H:%M:%S-0000") "$*" >> $LOG_FILE
}

get_removable_drives()
{
    [ -d /sys/block ] || return 0
    # xen will show cdroms as non-removable, so we will look for a first
    # partition
    test -f /proc/xen/xenbus
    local isXen="$?"
    # Skip the first two lines in /proc/partitions
    tail -n +3 /proc/partitions | while read minor major blcount devname; do
        fname="/sys/block/$devname/removable"
        [ -f $fname ] || continue
        content=$(< $fname)
        # Look for the first partition, if it exists it is definitely not a
        # removable device (cdroms have no partitions)
        part1="/sys/block/${devname}/${devname}1"
        if [ "x$content" == "x1" ]; then
            echo ${devname}
        elif [ x"$isXen" == "x0" -a ! -d $part1 ]; then
            echo ${devname}
        fi
    done
    # Look for cdroms too
    for f in /dev/{cdrom,hd}*; do
        if [ -L $f ]; then 
            devname=$(readlink $f)
            if [ "x$devname" == "x" ]; then
                continue
            fi
        elif [ -b $f ]; then
            devname=$( basename $f )
        else
            continue
        fi
        fname="/sys/block/$devname/removable"
        [ -f ${fname} ] || continue
        echo ${devname}
    done
    return 0
}

copy_iso_files()
{
    TEMPDIR=$(mktemp -d /tmp/mountprobe-XXXXXX)
    trap "rm -rf $TEMPDIR" EXIT
    # Location of client store on the cdrom
    local CLIENTS_CDROM_DIR=$TEMPDIR/etc/sfcb/clients
    local CONARY_ETC_DIR=/etc/conary
    local CONARY_FILES_SRC_DIR=${TEMPDIR}${CONARY_ETC_DIR}
    for dev in $(get_removable_drives | sort | uniq); do
        mount -o ro -t iso9660 /dev/${dev} $TEMPDIR 2>/dev/null
        retcode=$?
        if [ $retcode -ne 0 ]; then
            continue
        fi
        if [ -f $TEMPDIR/$SIGNATURE_FILE ]; then
            log_info "  Copying files from /dev/$dev"
            if [ -d $CONARY_FILES_SRC_DIR ]; then
                mkdir -p $CONARY_ETC_DIR
                # Make sure there is something for us to copy
                if [ $(ls -U $CLIENTS_CERT_DIR | wc -l) -gt 0 ]; then
                    cp --recursive --preserve=all $CONARY_FILES_SRC_DIR/* $CONARY_ETC_DIR
                fi
            fi
            if [ -d $CLIENTS_CDROM_DIR ]; then
                install -o $SFCB_USER -g $SFCB_GROUP -m 0600 $CLIENTS_CDROM_DIR/* $CLIENTS_CERT_DIR/
                # Fix for openssl 1.0 hash
                for crt in $CLIENTS_CERT_DIR/*; do
                    if [ -L $crt ];then
                        continue
                    fi
                    name="$(openssl x509 -hash -noout -in ${crt}).0"
                    if [ $name == $(basename ${crt}) ]; then
                        continue
                    fi
                    log_info "    Linking " $(basename ${crt}) "->" $CLIENTS_CERT_DIR/${name}
                    ln -sf $(basename ${crt}) $CLIENTS_CERT_DIR/${name};
                done
            fi
        fi
        umount $TEMPDIR 2>/dev/null
    done
    rm -rf $TEMPDIR
}

enable_cert_auth()
{
    # We require SSL client certificate authentication and no basic auth.
    local cfg="${SFCB_CONFIG_DIR}/sfcb.cfg"
    log_info "Enabling certificate authentication in $cfg"
    sed -i 's/doBasicAuth:\([[:space:]]*\).*$/doBasicAuth:\1false/;
            s/sslClientCertificate:.*/sslClientCertificate: require/;
            s/.*httpUser:.*$/httpUser: sfcb/;
            s/.*httpUserSFCB:.*$/httpUserSFCB:false/' ${cfg}
    sed -i "s|sslClientTrustStore:.*|sslClientTrustStore:${CLIENTS_CERT_DIR}|" ${cfg}
}

generate_vmware_certs()
{
    # If the vmware guest tools are not installed, there's not much point in
    # enabling the remote update, since we would not have an IP address to
    # manage this host
    [ -f /etc/init.d/vmware-guestd -o /etc/init.d/vmtoolsd ] || return
    # If the private key already exists, don't create it again
    log_info "  Generating X509 certificates for VMware Ready access"
    if [ ! -f /opt/vmware/etc/sfcb/file.pem ]; then
        $SFCB_SHARE_DIR/genSslCert.sh /opt/vmware/etc/sfcb > /dev/null 2>&1
        # We don't need a server cert in this directory. sfcb uses /etc/sfcb
        # Plus, as generated by genSslCert.sh, client.pem == server.pem
        rm -f /opt/vmware/etc/sfcb/server.pem
    fi
    certHash=$(openssl x509 -in /opt/vmware/etc/sfcb/client.pem -noout -hash)
    install -o $SFCB_USER -g $SFCB_GROUP -m 0600 /opt/vmware/etc/sfcb/client.pem $CLIENTS_CERT_DIR/${certHash}.0
}

start() {
    force="$1"
    shift
    if [ -z "$force" -a -e $LOCK_FILE ]; then
        log_info "Lock file exists; exiting"
        return
    fi
    touch $LOCK_FILE

    echo -n $"Enabling rPath Remote Updates"
    log_info "Enabling rPath Remote Access"
    enable_cert_auth
    mkdir -p $CLIENTS_CERT_DIR
    chmod 700 $CLIENTS_CERT_DIR
    chown sfcb.sfcb $CLIENTS_CERT_DIR
    copy_iso_files
    generate_vmware_certs
    echo
    log_info " Success"
    return 0
}

SIGNATURE_FILE=SECURITY-CONTEXT-BOOTSTRAP
if [ -d /usr/conary ]; then
    SFCB_CONFIG_DIR=/etc/conary/sfcb
    SFCB_SHARE_DIR=/usr/conary/share/sfcb
else
    SFCB_CONFIG_DIR=/etc/sfcb
    SFCB_SHARE_DIR=/usr/share/sfcb
fi
CLIENTS_CERT_DIR=${SFCB_CONFIG_DIR}/clients
SFCB_USER=sfcb
SFCB_GROUP=sfcb

cmd="$1"
shift
case "$cmd" in
    start)
        start
    ;;
    stop)
    ;;
    forcestart)
        start force
    ;;
    status)
        echo "Stopped"
    ;;
    *)
        echo $"Usage: $0 {start|stop|forcestart|status}"
        ;;
esac
exit 0
